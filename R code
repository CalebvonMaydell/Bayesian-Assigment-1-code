qbeta(.5, 3,14)
#0.1636542

#To get the coefficitent I wanted to a few things, so I will develop a product function to make this easier, this will also allow for easier multiplication later of the polynomials

product <- function(vec){   #multiply all elements of a matrix
    out <- 1
    for(i in 1:length(vec)){
         out <- out*vec[i]
    }
    out
}

c<-product(279:293)




#3.7 d)
n <- 278
p <- 2/15

x_values <- 0:n


probabilities <- dbinom(x_values, size = n, prob = p)

barplot(probabilities, col = "skyblue", main = "Binomial Distribution",
        xlab = "Number of Successes", ylab = "Probability", names.arg = NULL)

axis(side = 1, at = seq(0, n, by = 10), labels = seq(0, n, by = 10))



#4.8
menwbach <- c(1, 0, 0, 1, 2, 2, 1, 5, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 2, 1, 3, 2, 0, 0, 3, 0, 0, 0, 2, 1, 0, 2, 1)  # used chat gpt to add the commas for this and next line
mennobach<- c(1, 0, 0, 1, 2, 2, 1, 5, 2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 2, 1, 3, 2, 0, 0, 3, 0, 0, 0, 2, 1, 0, 2, 1,  
              2, 2, 1, 1, 2, 2, 1, 2, 1, 0, 2, 1, 1, 2, 0, 2, 2, 0, 2, 1, 0, 0, 3, 6, 1, 6, 4, 0, 3, 2, 0, 1, 0, 0, 0, 3, 0,
              0, 0, 0, 0, 1, 0, 4, 2, 1, 0, 0, 1, 0, 3, 2, 5, 0, 1, 1, 2, 1, 2, 1, 2, 0, 0, 0, 2, 1, 0, 2, 0, 2, 4, 1, 1, 1,
              2, 0, 1, 1, 1, 1, 0, 2, 3, 2, 0, 2, 1, 3, 1, 3, 2, 2, 3, 2, 0, 0, 0, 1, 0, 0, 0, 1, 2, 0, 3, 3, 0, 1, 2, 2, 2,
              0, 6, 0, 0, 0, 2, 0, 1, 1, 1, 3, 3, 2, 1, 1, 0, 1, 0, 0, 2, 0, 2, 0, 1, 0, 2, 0, 0, 2, 2, 4, 1, 2, 3, 2, 0, 0,
              0, 1, 0, 0, 1, 5, 2, 1, 3, 2, 0, 2, 1, 1, 3, 0, 5, 0, 0, 2, 4, 3, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 1,
              1, 0, 2, 1, 3, 3, 2, 2, 0, 0, 2, 3, 2, 4, 3, 3, 4, 0, 3, 0, 1, 0, 1, 2, 3, 4, 1, 2, 6, 2, 1, 2, 2)

sum(menwbach)  # 36
length(menwbach) #n = 38

length(mennobach) #n = 256
sum(mennobach) #341

set.seed(1234)
sampleswith <- rgamma(5000, shape = 38, rate = 39)
hist(sampleswith)
mean(sampleswith)

sampleswithout<-rgamma(5000, shape = 343, rate = 257)
hist(sampleswithout)

diff = sampleswithout - sampleswith

mean(diff)
sd(diff)
quantile(diff, 0.95)
quantile(diff, 0.05)

# Set a seed for reproducibility
set.seed(42)

# Generate a sample data
data_sample <- rpois(1000, lambda = 1.4)

# Plot the histogram
hist(data_sample, breaks = seq(-0.5, max(data_sample) + 0.5, by = 1), probability = TRUE,
     main = 'Histogram of Data Sample and Poisson Distribution',
     xlab = 'Value', ylab = 'Probability', col = 'lightblue', border = 'black')

# Overlay the Poisson distribution with lambda = 1.4
x_values <- 0:max(data_sample)
poisson_dist <- dpois(x_values, lambda = 1.4)
lines(x_values, poisson_dist, col = 'red', type = 'h', lwd = 2)

# Add a legend
legend('topright', legend = c('Data Sample', 'Poisson (Î»=1.4)'),
       fill = c('lightblue', 'red'), border = 'black')



num_samples <- 218

result_matrix <- matrix(0, ncol = 2, nrow = length(sampleswithout))

# Generate samples and count zeros and ones for each
for (i in 1:length(sampleswithout)) {
  poisson_params <- sampleswithout[i]
  sample <- rpois(218, lambda = poisson_params)  
  
  # Count zeros and ones
  num_zeros <- sum(sample == 0)
  num_ones <- sum(sample == 1)
  
  # Store the counts in the matrix
  result_matrix[i, ] <- c(num_zeros, num_ones)
}


sum(mennobach == 0)   #91
sum(mennobach == 1)   #60

# Assuming result_matrix is already defined
smoothScatter(result_matrix[,1], result_matrix[,2], main = "Scatter Plot with Density", xlab = "Zeros", ylab = "Ones", col = "blue", pch = 16)


smoothScatter(result_matrix[,1], result_matrix[,2], main = "Scatter Plot with Density", xlab = "Zeros", ylab = "Ones", col = "blue", pch = 16, xlim = c(0, 100), ylim = c(0, 100))

# Highlight the data 
points(91, 60, col = "red", pch = 16)


#5.2
m = 1:50   #"prior sample size"

mua = (m*75+1203.2)/(m+16)   #posterior mean for a
mub = mub = (m*75+1240)/(m+16) #posterior mean for b

sa =     1/(m+16)*(100*m+799.35 + 0.64*m/(m+16))   #posterior variance for a
sb =    1/(m+16)*(100*m+984.15 + 100*m/(m+16))    #posterior variance for b

# Assuming you have a vector m with length n
n <- length(m)

# Initialize palb as a vector of zeros or with appropriate dimensions
palb <- numeric(n)


for (i in 1:n) {
    if (sa[i] > 0 && sb[i] > 0) {
        samplea <- rnorm(1000, mua[i], sa[i])
        sampleb <- rnorm(1000, mub[i], sb[i])
        palb[i] <- mean(samplea < sampleb)
    } else {
        # Handle the case where standard deviations are zero, from chat gpt to fix an error
        palb[i] <- NA
    }
}

plot(m,palb)
summary(lm(palb~m)) #linear model will show if theres a linear trend




